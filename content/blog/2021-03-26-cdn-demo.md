---
title: "Content Delivery Network with Zenoh"
date: 2021-03-27
menu: "blog"
weight: 300
description: "27 March 2021 -- Paris."
draft: false
---

## Why a Content Delivery Network?
A Content Delivery Network (CDN) is a popular solution based on geographically distributed servers that work together by collecting the data to the user’s nearest node. Edge servers, located close to the end users, are the base infrastructure a CDN is built upon.

CDN is increasingly important in sharing internet contents, such as images, videos, html pages, and so on, and most of the nowadays traffic is served through a CDN in order to improve users’ experience and ability to manage increasingly large media and contents.

Among the several advantages the CDN brings, the main once are:

- Performance and latency
  - Less traffic on server that produces the content
  - Less network latency
- Resource consumption
  - Lower overal bandwidth usage
- Security
  - Region-aware server
  - DDoS prevention


## General CDN vs. Zenoh CDN
The architecture and the geographical coverage and presence of a CDN may differ in relation to the content and the service to serve but the basic concepts and building blocks are the following:
- **Origin server.** The server that produces the initial content.
- **Point of presence (POP).** Each region is served by a CDN based on a POP that can be considered as an edge server that manages the traffic for the region and guarantees the local CDN functions such as caching, security (in particular DDOS prevention), networking and content delivery. 
- **Users.** Within a certain region, users connect to the corresponding edge server instead of the origin server.
- When the user request data, based on monitoring and metrics, those data are trasfered from the origin server to the edge server.

Here a schematic architecture of a CDN:

![msg-sec](../../img/cdn.png)

[**Zenoh**](https://github.com/eclipse-zenoh/zenoh) is a multi-functions protocol that provides pub/sub messaging, geo-distributed storages, queries and computations. The flexibility of Zenoh primitives allows to adopt it also in a wide range of usecases, only apparently far away from it, such as a CDN implementation.

The main differences between implementing a CDN with Zenoh or with a typical mainstream approach are resumed as follows.

**General CDN vs. Zenoh-based CDN** 
- **Flat Organization.** Zenoh is agnostic from the node where it runs and through the Zenoh configuration it is possbile to easily specify the network organization and topology. Thus, the origin server is considered just as a node with Zenoh router running on it, similarly, to every edge server.
- **Edge server.** It’s a server with a running Zenoh router, connected to the origin server.
- **Region.** Area where every connection is routed towards the nearest edge server. Ideally, every edge server is responsible for a certain region and every user wiht a certain region connects to the same edge server.
- **Users.** Any device that wants to connect (physical sensors, IoT devices, mobile devices, etc.)

**Benefits of using Zenoh**
- **Architecture.** Support for both hierarchical and flat organization, just by handling the configuration specified for Zenoh.
- **Synchronization.** Zenoh natively provides the required features to synchronize contents although is also a pub/sub protocol.


## Users involved

Before talking of how to build a CDN, it’s crucial to understand the roles for the different users involved. Users may generally be divided into three levels of domain:

**Infrastructure manager**
- Perform the Initial configuration on the nodes
- Deploy of the Zenoh routers
- Create the backend for each Zenoh router

**Admin**
- Analyze the workload/traffic in order to decide whether to enable new storages
- Create new storages on edge nodes

**User**
- Read/write data from/to Zenoh
- Each user is always connected to the same edge node notwithstanding the data location


## Demo steps

Initial scenario:
- Both origin and edge servers do not contain any data
- Two nodes that contains connected Zenoh routers (1 origin server, 1 edge server) with backend-filesystem enabled
- Backend created and available on both nodes.

Steps:
1. Admin creates the storage to the origin server
2. A client writes data to the origin server by using the previously created storage:
    - It creates a folder «fs_storage» and a text file «content»
    - Other clients can access the «content» file, connecting from their edge servers
3. Monitoring and migration alerting
4. Admin creates the storage to the edge server
    - Clients connected to that edge server retrieve the data locally

Final scenario:
- Both origin and edge servers contain the files within the folder «fs_storage/…»


## Initial configuration

Zenoh and the related projects in its ecosystem are open-source projects available on github. For this demo we use the following projects

{{<table "table table-striped table-bordered">}}
| Projects                   |  Overview                                        |
|:---------------------------|:-------------------------------------------------|
| **Zenoh**                  | Zero overhead pub/sub, store/query and compute protocol [[source code]](github.com/eclipse-zenoh/zenoh)  |
| **Zenoh-backend-fielsystem** | Backend and Storages for zenoh using the file system [[source code]](github.com/eclipse-zenoh/zenoh-backend-filesystem) |
| **Zenoh-python**            | Python client API for zenoh [[source code]](github.com/eclipse-zenoh/zenoh-python) |
{{</table>}}


and we initialize each node with the minimal set of tools to be used:

1.	Install Cargo and Rust (nightly-build)
2.	Build the “Zenoh” project and the “Zenoh-backend-filesystem” project
    > **Warning:** the 2 project must be built with the same Rustc version to enable compatilities between them.
3.	Compile both projects and setup Zenoh with the zbackend_fs library in ~/.zenoh/lib ([see the doc]( https://github.com/eclipse-zenoh/zenoh-backend-filesystem/blob/master/README.md#file-system-backend-for-eclipse-zenoh))
4.	Install Python3 for the client calls and setup the Zenoh-python project ([see the doc](https://github.com/eclipse-zenoh/zenoh-python/blob/master/README.md#eclipse-zenoh-python-api))


## Run the Demo

**Execute Zenoh router for each server**
    
    # Set the router options:

    $ address="tcp/<ip_node>"
    $ port="7447"
    $ api_port="8001"
    $ ZENOH_OPTIONS=" -l $address:$port
                      --rest-http-port$api_port
	                  {-e $address:$connecting_port}"

    $ ./target/release/zenohd $ZENOH_OPTIONS

In particular, the option -e of Zenoh is used to connect the routers together. This option is required for edge servers that want to connect to the origin server or P2P/mesh configuration and is not needed on the origin server.


**Creates the backend on all Zenoh routers and the storage only on the origin server** 

In fact the edge servers are activated to dispatch the content only if local users request it, thus, initially, the edge servers do not have any storages which are created on demand in relation to the traffic on the region.
[Check how to create backend and storage on Zenoh](https://github.com/eclipse-zenoh/zenoh-backend-filesystem#file-system-backend-for-eclipse-zenoh)

After adding the backend on the origin server and on the edge server, Zenoh routers will consider *$ZBACKEND_FS_ROOT* directory as the root folder where to store future data.

Here an example about the creation of backend and storage through REST api and Python client.

    # Environment variables:
    $ address="tcp/<ip_origin>"	        //router (origin/edge) address
    $ path_expr="/demo/example/**"		//storage path expression
    $ path_prefix="/demo/example"	 	//prefix to strip form the path_expre
    $ storage_folder="fs_storage"           //directory to store the file
    $ id="local"                           //identifier for the backend/storage

    # Backend - REST api:
    $ curl -X PUT -H 'content-type:application/properties' http://$address:8001/@/router/
    local/plugin/storages/backend/fs
    
    # Backend - Python client:
    $ from zenoh import Zenoh, Value
    $ def main(address, id):
        $ path = '/@/router/' + id + '/plugin/storages/backend/fs'
        $ zenoh = Zenoh({'mode':'client','peer':'{}'.format(address),})
        $ workspace = zenoh.workspace()
        $ workspace.put(path, {})
   
    # Storage - REST api:
    $ curl -X PUT -H 'content-type:application/properties' -d "path_expr=$path_expr;
    path_prefix=$path_prefix;dir=$storage_folder" http://$address:8001/@/router/local/plugin/storages
    /backend/fs/storage/example

    # Storage – Python client:
    $ from zenoh import Zenoh, Value
    $ def main(address, id, path_expr, path_prefix, storage_folder): 
    $    path = '/@/router/' + id + '/plugin/storages/backend/fs/storage/local'
    $    zenoh = Zenoh({'mode':'client’})
    $    workspace = zenoh.workspace()
    $    value = {'path_expr':path_expr,'path_prefix':path_prefix,'dir':storage_folder}
    $    workspace.put(path, value)

We can check that at path *$ZBACKEND_FS_ROOT* of the node has been created the folder *$storage_folder*, where Zenoh will put the files to store on the filesystem and expose them for other routers.


**Client writes some data on Origin server**

When a Client creates a content, the Zenoh router is called to store it through the PUT api, by using a key-value pair:

    $ locator="/demo/example/content"
    $ value="Some_data" //string, int, image or custom file

    # Python code fo the PUT api

    $ from zenoh import Zenoh, Value
    $ def main(key, value): 
    $     zenoh = Zenoh({'mode':'client'})
    $     workspace = zenoh.workspace()
    $     value = {‘key’:value}
    $     workspace.put(path, value)

After the PUT, we can check that at path *$ZBACKEND_FS_ROOT* there is the file *$storage_folder/content*

## Monitoring
Initially, edge servers are not equipped with storage and do not store any data until users in the region will start to request a certain content and the traffic will go above a certain threshold. In fact, the edge servers are created and migrated in a proactive way (to avoid slowing down), in relation to:
- **resource available** on the origin server, to avoid the server to hang and continue to be responsive
- **traffic patterns**, to minimize network latency and keep high RTT performance

In order to enable a monitoring component able to trigger the creation of storages on edge servers, it is possible to follow two directions:
1.	**Zenoh-internal solution** (for basic usecases):
    - Zenoh is able to keep trace of the published messages
    - Trivial implementation: few lines of code allow to retrieve the number of message arrived to the Zenoh router and decide whether to enable the edge server.
2.	**External Monitoring** (for real-world scenarios), able to report many different metrics at a fine-grained level. For example:
    - Resource information:
      - number of process waiting to be executed by the cpu
      - amount of memory available/used
      - bandwidth available
    - Traffic information:
      - number of connections
      - number of calls


## Retrieve Data through the CDN

So far, to retrieve a content, if a client is connected to the origin server, it receives the data directly from it. Otherwise, if a client is connected to the edge server, the edge server contacts the origin server to look for the data and the edge server routes the content to the client without saving anything locally.

When required, the system admininistrator creates the storage on the edge servers that are experiencing an higher traffic on the resources, in the same way the storage has been created above for the origin server.

In this way, the Zenoh routers on the edge servers synchronize their storages on the filesystem under the folder $storage_folder with the router on the origin server and it stores the files locally.
Successively, all the users connected with that edge server can benefit by retrieving the files locally.

The Zenoh-backend-filesystem library has been developed to synchronize the storage folder created during the storage creation, thus, the files will be syncronized when the storage will be created and any time there will be a modification within the folder.
In particular, if multiple Zenoh routers contain the same key, Zenoh performs a query on all the matching storages and consolidate the results at the client side based on the highest timestamp.


# Related usecase: a Distributed web application

By using the features exposed by Zenoh, Zenoh-backend-filesystem and Zenoh-plugin-webserver

{{<table "table table-striped table-bordered">}}
| Projects                   |  Overview                                        |
|:---------------------------|:-------------------------------------------------|
| **Zenoh**                  | Zero overhead pub/sub, store/query and compute protocol [[source code]](github.com/eclipse-zenoh/zenoh)  |
| **Zenoh-backend-fielsystem** | Backend and Storages for zenoh using the file system [[source code]](github.com/eclipse-zenoh/zenoh-backend-filesystem) |
| **Zenoh-plugin-webserver**  | HTTP server mapping URLs to Zenoh paths [[source code]](https://github.com/eclipse-zenoh/zenoh-plugin-webserver) |
{{</table>}}


it is also possible to create a distributed web application, where the different parts of the web application are stored on different geo-distributed Zenoh storages and expose the web application externally as one.

The usecase architecture is highlighted in the following figure, where we suppose a distributed developing team is working simultaneously on the same distributed web app and the resultant content is dispatched through the web server Zenoh router.

![msg-sec](../../img/distributed_webapp.png)

The basic architecture is composed of:
- At least 2 Zenoh routers (**data routers**):
  - Each router contains a part of the web application
  - They have the backend enabled and storages enabled in read/write modes
  - They receive the files developed by the web application developers
- Only 1 Zenoh router (**web server router**):
  - It has backend enabled and a storage in a read-only mode
  - It works as web server, getting the data from the data routers, exposing the whole web application and listening for incoming connection

This demo is not detailed because it uses the same concepts and commands explained for the one about the Content Delivery Network, thus, is easilly reproducible, just changing the files we put into the backend root folder (*$ZBACKEND_FS_ROOT*) and we want to share with the other Zenoh routers! 
