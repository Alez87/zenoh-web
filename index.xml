<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute Protocol.</title><link>/</link><description>Recent content on zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute Protocol.</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 30 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>What is zenoh?</title><link>/docs/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/overview/</guid><description>With the steady increase in the number of network connected devices we are experiencing a new level of heterogeneity with respect to computing, storage and communication capabilities, as well as new challenges with respect to the scale at which data is produced and needs to be consumed.
Additionally, for performance, efficiency and privacy reasons, there is an increasing desire to keep the data processing as close as possible to the source, while at the same time not hindering access to geographically remote applications.</description></item><item><title>Zenoh Tidings</title><link>/blog/2020-06-29-zenoh-tidings/</link><pubDate>Tue, 30 Jun 2020 00:00:00 +0000</pubDate><guid>/blog/2020-06-29-zenoh-tidings/</guid><description>In our last blog we had announced a rewrite of zenoh in Rust. The wrote the first version of zenoh in OCaml, a super-neat ML-derived functional programming language. OCaml allowed us to experiment very quickly and have good performances. Yet, one of the major feedback we were receiving from the community was that few people knew this programming language and this was limiting contributions. Beside, we had the desire to make zenoh even faster and smaller.</description></item><item><title>A Year Full of Zenoh</title><link>/blog/2020-01-01-zenohtude/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>/blog/2020-01-01-zenohtude/</guid><description>First of all we would like to take a moment to wish all of you a 2020 filled with joy, health, peace and success.
This year marks a very important landmark for us. After having kicked-off the Eclipse Edge Native working group, last December, we are bringing zenoh to Eclipse and are starting to work a Rust rewrite of the zenoh router. As part for the rewrite we have just about to complete a review of the zenoh protocol and will be updating the specification accordingly in the weeks to come.</description></item><item><title>For a Quick Test</title><link>/docs/getting-started/quick-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/quick-test/</guid><description>This page describe how to perform a quick test of zenoh.
Run zenoh in Docker The zenoh infrastructure is also available in a Docker image. You can deploy a single instance on your local host just running:
docker pull eclipse/zenoh docker run --init -p 7447:7447/tcp -p 7447:7447/udp -p 8000:8000/tcp eclipse/zenoh The ports used by zenoh are the following:
7447/tcp : the zenoh protocol via TCP 7447/udp : the zenoh scouting protocol using UDP multicast (for clients to automatically discover the router) 8000/tcp : the zenoh REST API First tests using the REST API The complete Eclipse zenoh&amp;rsquo;s key/value space is accessible through the REST API, using regular HTTP GET, PUT and DELETE methods.</description></item><item><title>Installation</title><link>/docs/getting-started/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/installation/</guid><description>To get up and running with zenohyou will have to install the router and then get hold of the API you would like to use to write your applications.
Installing zenoh&amp;rsquo;s router At the present stage zenoh&amp;rsquo;s router is supported only on Linux and MacOS. However, for other platforms, you can use the Docker image.
Below are the detailed information on how to install the binaries directly on supported platforms (i.</description></item><item><title>Your First zenoh app</title><link>/docs/getting-started/first-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/first-app/</guid><description>Getting started with zenoh is quite straightforward. Below we will show you how to create a simple telemetry application. Let&amp;rsquo;s assume that we have some sensor, say a temperature sensor, and we want to store this temperature into a zenoh storage. Later on, we want to retrieve this temperature from the zenoh storage.
Before cranking some code, let&amp;rsquo;s define some terminology.
zenohdeals with keys/valueswhere each key is a pathand is associated to a value.</description></item><item><title>Abstractions</title><link>/docs/manual/abstractions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/abstractions/</guid><description>Zenoh is a distributed service to define, manage and operate on key/value spaces.
The key abstractions at the core of zenoh are the following:
Key Zenoh uses paths as keys. In all zenoh documentations, &amp;ldquo;key&amp;rdquo; and &amp;ldquo;path&amp;rdquo; are synonym.
Path A set of strings separated by '/' , as in a filesystem path. A Path cannot contain any '*' character.
Examples of paths: /demo/example/test , /com/adlink/building/fr/floor/1/office/2 &amp;hellip;
A path can be absolute (i.</description></item><item><title>Zenoh backends</title><link>/docs/manual/backends/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/backends/</guid><description>The current version of zenoh only supports a memory backend which store paths/values in an internal hashmap. By default this it is available at zenoh router startup.
Note that it is not persistent: as soon as the zenoh router stops, all the paths/values stored in this backend are lost.
You can create storages using this memory backend in two ways:
At zenoh router startup, using the '--mem-storage&amp;rsquo; option (you can use it several times).</description></item><item><title>API documentations</title><link>/docs/apis/apis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/apis/apis/</guid><description>All the client APIs documentations are avaliable on Read the Docs:
Rust https://zenoh-rust.readthedocs.io/
Python https://zenoh-python.readthedocs.io/
REST API Zenoh also offers a REST API via the zenoh-http plugin. When starting zenoh with default options, this HTTP plugin is automatically started on port 8000 and ready to answer HTTP requests.
The full zenoh key/value space is accessible via this REST API, including the Admin Space under the '/@'prefix.
GET Binds to the get(selector) operation on zenoh.</description></item><item><title>The zenoh Community</title><link>/community/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/community/</guid><description>Communication The zenoh community is most readily found on its gitter channel, where you&amp;rsquo;re welcome to ask questions, report problems, or pitch ideas.
Issues Github is used for tracking issues.
If your issue is related to the zenoh protocol, the infrastructure or the REST API, the primary location is https://github.com/eclipse-zenoh/zenoh/issues.
If your issue is related to an API, please use the Github issues related to this API:
Python API Java API Go API If you&amp;rsquo;re a zenoh user, you&amp;rsquo;re highly encouraged to keep an eye on these issues and jump in on the discussions, to help us understand how design tradeoffs might affect you.</description></item><item><title>Third-party crates</title><link>/community/third-party/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/community/third-party/</guid><description>Currently the futures, zenoh-core, zenoh-service, and zenoh-proto crates provide the foundation for the Tokio ecosystem. There&amp;rsquo;s a growing set of crates outside of Tokio itself, however, filling in more functionality!
zenoh-curl is an HTTP client library backed by the libcurl C library. zenoh-timer is a timer library providing finer-grained control over timers and helpful timeout facilities over the types in zenoh-core. zenoh-tls is a library for TLS streams backed by native-tls.</description></item></channel></rss>